import EventEmitter from "events";
import { MetadataFactory } from '@aurahelper/metadata-factory';
import { XMLCompressor } from '@aurahelper/xml-compressor';
import { XML } from '@aurahelper/languages';
import { MetadataTypes, CoreUtils, MetadataType, MetadataDetail, FileChecker, FileWriter, FileReader, PathUtils } from "@aurahelper/core";
const XMLParser = XML.XMLParser;
const Utils = CoreUtils.Utils;
const Validator = CoreUtils.Validator;

const SORT_ORDER = XMLCompressor.getSortOrderValues();

const TYPES_XML_RELATION: { [key: string]: any } = {
    AssignmentRules: {
        singularName: MetadataTypes.ASSIGNMENT_RULE,
        collection: 'assignmentRule',
        fieldKey: 'fullName',
    },
    AutoResponseRules: {
        singularName: MetadataTypes.AUTORESPONSE_RULE,
        collection: 'autoresponseRule',
        fieldKey: 'fullName',
    },
    EscalationRules: {
        singularName: MetadataTypes.ESCALATION_RULE,
        collection: 'escalationRule',
        fieldKey: 'fullName',
    },
    MatchingRules: {
        singularName: MetadataTypes.MATCHING_RULE,
        collection: 'matchingRules',
        fieldKey: 'fullName',
    },
    CustomLabels: {
        singularName: MetadataTypes.CUSTOM_LABEL,
        collection: 'labels',
        fieldKey: 'fullName',
    },
    SharingCriteriaRule: {
        parentName: MetadataTypes.SHARING_RULES,
        collection: 'sharingCriteriaRules',
        fieldKey: 'fullName',
    },
    SharingOwnerRule: {
        parentName: MetadataTypes.SHARING_RULES,
        collection: 'sharingOwnerRules',
        fieldKey: 'fullName',
    },
    SharingGuestRule: {
        parentName: MetadataTypes.SHARING_RULES,
        collection: 'sharingGuestRules',
        fieldKey: 'fullName',
    },
    SharingTerritoryRule: {
        parentName: MetadataTypes.SHARING_RULES,
        collection: 'sharingTerritoryRules',
        fieldKey: 'fullName',
    },
    WorkflowAlert: {
        parentName: MetadataTypes.WORKFLOW,
        collection: 'alerts',
        fieldKey: 'fullName',
    },
    WorkflowKnowledgePublish: {
        parentName: MetadataTypes.WORKFLOW,
        collection: 'knowledgePublishes',
        fieldKey: 'fullName',
    },
    WorkflowFieldUpdate: {
        parentName: MetadataTypes.WORKFLOW,
        collection: 'fieldUpdates',
        fieldKey: 'fullName',
    },
    WorkflowRule: {
        parentName: MetadataTypes.WORKFLOW,
        collection: 'rules',
        fieldKey: 'fullName',
    },
    WorkflowTask: {
        parentName: MetadataTypes.WORKFLOW,
        collection: 'tasks',
        fieldKey: 'fullName',
    },
    WorkflowOutboundMessage: {
        parentName: MetadataTypes.WORKFLOW,
        collection: 'outboundMessages',
        fieldKey: 'fullName',
    }
};

const METADATA_WITH_CHILDS: { [key: string]: any } = {
    Workflow: [
        MetadataTypes.WORKFLOW_ALERT,
        MetadataTypes.WORKFLOW_KNOWLEDGE_PUBLISH,
        MetadataTypes.WORKFLOW_FIELD_UPDATE,
        MetadataTypes.WORKFLOW_RULE,
        MetadataTypes.WORKFLOW_TASK,
        MetadataTypes.WORKFLOW_OUTBOUND_MESSAGE
    ],
    SharingRules: [
        MetadataTypes.SHARING_CRITERIA_RULE,
        MetadataTypes.SHARING_OWNER_RULE,
        MetadataTypes.SHARING_GUEST_RULE,
        MetadataTypes.SHARING_TERRITORY_RULE
    ],
    CustomObject: [
        MetadataTypes.CUSTOM_FIELD,
        MetadataTypes.INDEX,
        MetadataTypes.BUSINESS_PROCESS,
        MetadataTypes.COMPACT_LAYOUT,
        MetadataTypes.RECORD_TYPE,
        MetadataTypes.WEBLINK,
        MetadataTypes.VALIDATION_RULE,
        MetadataTypes.SHARING_REASON,
        MetadataTypes.LISTVIEW,
        MetadataTypes.FIELD_SET
    ]
};

const EVENTS: { [key: string]: string } = {
    START_TYPE: 'startType',
    END_TYPE: 'endType',
};

/**
 * Class to ignore metadata from your salesforce projects or from a JSON metadata object. 
 * This class will be specially util in some use cases, like Custom Label values unique for every environment (like ids...), 
 * or to avoid deploy some user permissions, or when you creating autogenerated package (from git for example) and like to excludo some metadata automatically
 * 
 * The setters methods are defined like a builder pattern to make it more usefull
 */
export class Ignore {

    ignoreFile: string;
    typesToIgnore?: string[];
    remove: boolean;
    compress: boolean;
    sortOrder: string;
    private _event: EventEmitter;

    /**
     * Constructor to instance a new Ignore object
     * @param {string} [ignoreFile] Path to the ignore file
     */
    constructor(ignoreFile?: string) {
        this.ignoreFile = ignoreFile || './.ahignore.json';
        this.typesToIgnore = undefined;
        this.remove = false;
        this.compress = false;
        this.sortOrder = SORT_ORDER.ALPHABET_ASC;
        this._event = new EventEmitter();
    }

    /**
     * Method to set the callback function to handle the event Start Process Metadata Type to handle the ignore progress 
     * @param {Function} callback callback function to handle the Start Process Metadata Type Event 
     * 
     * @returns {Ignore} Return the ignore object instance
     */
    onStartProcessType(callback: (metadataTypeName: string) => void) {
        this._event.on(EVENTS.START_TYPE, callback);
        return this;
    }

    /**
     * Method to set the callback function to handle the event End Process Metadata Type to handle the ignore progress 
     * @param {Function} callback callback function to handle the End Process Metadata Type Event 
     * 
     * @returns {Ignore} Return the ignore object instance
     */
    onEndProcessType(callback: (metadataTypeName: string) => void) {
        this._event.on(EVENTS.END_TYPE, callback);
        return this;
    }

    /**
     * Method to set the ignore file to ignore the metadata types
     * @param {string} ignorefile Path to the ignore file
     * 
     * @returns {Ignore} Return the ignore object instance
     */
    setIgnoreFile(ignoreFile: string): Ignore {
        this.ignoreFile = ignoreFile;
        return this;
    }

    /**
     * Method to set the Metadata Name or Names to ignore
     * @param {string | string[]} typesToIgnore Metadata type API Name or List with the Metadata Type API Names to ignore. This parameter is used to ignore only the specified metadata (also must be in ignore file) and avoid ignore all metadata types specified on the file.
     * 
     * @returns {Ignore} Return the ignore object instance
     */
    setTypesToIgnore(typesToIgnore: string | string[]): Ignore {
        this.typesToIgnore = Utils.forceArray(typesToIgnore) as string[];
        return this;
    }

    /**
     * Method to set if remove metadata from Metadata Object or only unselect it
     * @param {boolean} remove True to remove ignored elements from the result object, false only for unselect elements. If undefined or not pass parameter, also set to true.
     * 
     * @returns {Ignore} Return the ignore object instance
     */
    removeData(remove: boolean): Ignore {
        this.remove = (Utils.isBoolean(remove)) ? remove : true;
        return this;
    }

    /**
     * Method to set if compress the affected XML Files when the ignore project metadata
     * @param {boolean} compress True to compress the XML Files, false in otherwise. If undefined or not pass parameter, also set to true.
     * 
     * @returns {Ignore} Return the ignore object instance
     */
    setCompress(compress: boolean): Ignore {
        this.compress = (Utils.isBoolean(compress)) ? compress : true;
        return this;
    }

    /**
     * Method to set the sort order for the XML Elements when compress the files
     * @param {string} sortOrder Sort order to order the XML elements. Values: simpleFirst, complexFirst, alphabetAsc or alphabetDesc. (alphabetDesc by default)
     * 
     * @returns {Ignore} Return the ignore object instance
     */
    setSortOrder(sortOrder: string): Ignore {
        this.sortOrder = sortOrder;
        return this;
    }

    /**
     * Method to set Simple XML Elements first as sort order (simpleFirst)
     * @returns {Ignore} Return the ignore object instance
     */
    sortSimpleFirst(): Ignore {
        this.sortOrder = SORT_ORDER.SIMPLE_FIRST;
        return this;
    }

    /**
     * Method to set Complex XML Elements first as sort order (complexFirst)
     * @returns {Ignore} Return the ignore object instance
     */
    sortComplexFirst(): Ignore {
        this.sortOrder = SORT_ORDER.COMPLEX_FIRST;
        return this;
    }

    /**
     * Method to set Alphabet Asc as sort order (alphabetAsc)
     * @returns {Ignore} Return the ignore object instance
     */
    sortAlphabetAsc(): Ignore {
        this.sortOrder = SORT_ORDER.ALPHABET_ASC;
        return this;
    }

    /**
     * Method to set Alphabet Desc as sort order (alphabetDesc)
     * @returns {Ignore} Return the ignore object instance
     */
    sortAlphabetDesc(): Ignore {
        this.sortOrder = SORT_ORDER.ALPHABET_DESC;
        return this;
    }

    /**
     * Method to ignore Metadata types from a Metadata JSON Object or Metadata JSON file. If You choose removeData option, the metadata will be deleted from the result object, in other only will be unselected
     * @param {string | { [key: string]: MetadataType }} metadataOrPath Metadata JSON Object or Metadata JSON file path. You can pass an object or file to process, or process the Ignore metadata Or path setted on object
     * 
     * @returns {{ [key: string]: MetadataType }} Return a Metadata JSON Object with the ignored metadata unselected or removed
     * 
     * @throws {WrongFilePathException} If the metadata file path or ignore file path is not a String or can't convert to absolute path
     * @throws {FileNotFoundException} If the metadata file path or ignore file not exists or not have access to it
     * @throws {InvalidFilePathException} If the metadata file path or ignore file is not a file
     * @throws {WrongFormatException} If metadata file path or ignore file is not a JSON file or Metadata Object are wrong
     */
    ignoreMetadata(metadataOrPath: string | { [key: string]: MetadataType }): { [key: string]: MetadataType } {
        metadataOrPath = Validator.validateMetadataJSON(metadataOrPath);
        const metadata = Utils.clone(metadataOrPath);
        const ignoredMetadata = createIgnoreMetadataMap(Validator.validateJSONFile(this.ignoreFile, 'Ignore'));
        for (const metadataTypeName of Object.keys(ignoredMetadata)) {
            const typeData = TYPES_XML_RELATION[metadataTypeName];
            if (metadata[metadataTypeName] || (typeData && typeData.singularName)) {
                if (this.typesToIgnore && !this.typesToIgnore.includes(metadataTypeName)) {
                    continue;
                }
                this._event.emit(EVENTS.START_TYPE, metadataTypeName);
                switch (metadataTypeName) {
                    case MetadataTypes.CUSTOM_LABELS:
                        ignoreMetadataCustomLabels(metadata[metadataTypeName], ignoredMetadata[metadataTypeName], metadata[typeData.singularName], this.remove);
                        break;
                    case MetadataTypes.MATCHING_RULES:
                    case MetadataTypes.ASSIGNMENT_RULES:
                    case MetadataTypes.AUTORESPONSE_RULES:
                    case MetadataTypes.ESCALATION_RULES:
                        if (metadata[typeData.singularName]) {
                            ignoreMetadataRules(metadata[metadataTypeName], ignoredMetadata[metadataTypeName], metadata[typeData.singularName], this.remove);
                        }
                        break;
                    case MetadataTypes.SHARING_CRITERIA_RULE:
                    case MetadataTypes.SHARING_OWNER_RULE:
                    case MetadataTypes.SHARING_GUEST_RULE:
                    case MetadataTypes.SHARING_TERRITORY_RULE:
                    case MetadataTypes.WORKFLOW_ALERT:
                    case MetadataTypes.WORKFLOW_KNOWLEDGE_PUBLISH:
                    case MetadataTypes.WORKFLOW_FIELD_UPDATE:
                    case MetadataTypes.WORKFLOW_RULE:
                    case MetadataTypes.WORKFLOW_TASK:
                    case MetadataTypes.WORKFLOW_OUTBOUND_MESSAGE:
                    case MetadataTypes.WORKFLOW:
                    case MetadataTypes.SHARING_RULES:
                        ignoreMetadataWithChilds(metadata[metadataTypeName], ignoredMetadata[metadataTypeName], metadata, this.remove);
                        break;
                    case MetadataTypes.CUSTOM_OBJECT:
                    case MetadataTypes.CUSTOM_FIELD:
                    case MetadataTypes.INDEX:
                    case MetadataTypes.BUSINESS_PROCESS:
                    case MetadataTypes.COMPACT_LAYOUT:
                    case MetadataTypes.RECORD_TYPE:
                    case MetadataTypes.WEBLINK:
                    case MetadataTypes.VALIDATION_RULE:
                    case MetadataTypes.SHARING_REASON:
                    case MetadataTypes.LISTVIEW:
                    case MetadataTypes.FIELD_SET:
                        ignoreMetadataFromCustomObjects(metadata[metadataTypeName], ignoredMetadata[metadataTypeName], metadata, this.remove);
                        break;
                    default:
                        ignoreOtherMetadataTypes(metadata[metadataTypeName], ignoredMetadata[metadataTypeName], this.remove);
                        break;
                }
                this._event.emit(EVENTS.END_TYPE, metadataTypeName);
            }
        }
        return MetadataFactory.deserializeMetadataTypes(metadata, true);
    }

    /**
     * Method to ignore Metadata types from your local project. This method can delete some data from XML Files or entire XML files or folders according the ignore file data
     * @param {string} projectPath Salesforce Project root path
     * @param {MetadataDetail[]} metadataDetails Metadata details list
     * 
     * @throws {WrongFilePathException} If the ignore file path is not a String or can't convert to absolute path
     * @throws {FileNotFoundException} If the ignore file not exists or not have access to it
     * @throws {InvalidFilePathException} If the ignore file is not a file
     * @throws {WrongFormatException} If ignore file is not a JSON file
     * @throws {WrongDirectoryPathException} If the project path is not a String or can't convert to absolute path
     * @throws {DirectoryNotFoundException} If the project path directory not exists or not have access to it
     * @throws {InvalidDirectoryPathException} If the project path is not a directory
     */
    ignoreProjectMetadata(projectPath: string, metadataDetails: MetadataDetail[]): void {
        projectPath = Validator.validateFolderPath(projectPath, 'Project');
        const ignoredMetadata = createIgnoreMetadataMap(Validator.validateJSONFile(this.ignoreFile, 'Ignore'));
        metadataDetails = MetadataFactory.createMetadataDetails(metadataDetails);
        const folderMetadataMap = MetadataFactory.createFolderMetadataMap(metadataDetails);
        const metadataFromFileSystem = MetadataFactory.createMetadataTypesFromFileSystem(folderMetadataMap, projectPath);
        for (const metadataTypeName of Object.keys(ignoredMetadata)) {
            let typeData = TYPES_XML_RELATION[metadataTypeName];
            if (metadataFromFileSystem[metadataTypeName] || (typeData && typeData.singularName)) {
                if (this.typesToIgnore && !this.typesToIgnore.includes(metadataTypeName)) {
                    continue;
                }
                this._event.emit(EVENTS.START_TYPE, metadataTypeName);
                switch (metadataTypeName) {
                    case MetadataTypes.CUSTOM_LABELS:
                        if (metadataFromFileSystem[metadataTypeName] && ignoredMetadata[metadataTypeName]) {
                            ignoreFileCustomLabels(metadataFromFileSystem[metadataTypeName], ignoredMetadata[metadataTypeName], this.compress, this.sortOrder);
                        }
                        break;
                    case MetadataTypes.MATCHING_RULES:
                    case MetadataTypes.ASSIGNMENT_RULES:
                    case MetadataTypes.AUTORESPONSE_RULES:
                    case MetadataTypes.ESCALATION_RULES:
                        if (metadataFromFileSystem[typeData.singularName]) {
                            ignoreFileRules(metadataFromFileSystem[metadataTypeName], ignoredMetadata[metadataTypeName], metadataFromFileSystem[typeData.singularName], this.compress, this.sortOrder);
                        }
                        break;
                    case MetadataTypes.SHARING_CRITERIA_RULE:
                    case MetadataTypes.SHARING_OWNER_RULE:
                    case MetadataTypes.SHARING_GUEST_RULE:
                    case MetadataTypes.SHARING_TERRITORY_RULE:
                    case MetadataTypes.WORKFLOW_ALERT:
                    case MetadataTypes.WORKFLOW_KNOWLEDGE_PUBLISH:
                    case MetadataTypes.WORKFLOW_FIELD_UPDATE:
                    case MetadataTypes.WORKFLOW_RULE:
                    case MetadataTypes.WORKFLOW_TASK:
                    case MetadataTypes.WORKFLOW_OUTBOUND_MESSAGE:
                        if (metadataFromFileSystem[metadataTypeName] && ignoredMetadata[metadataTypeName]) {
                            ignoreFileMetadataFromFiles(metadataFromFileSystem[metadataTypeName], ignoredMetadata[metadataTypeName], this.compress, this.sortOrder);
                        }
                        break;
                    case MetadataTypes.CUSTOM_OBJECT:
                        if (metadataFromFileSystem[metadataTypeName] && ignoredMetadata[metadataTypeName]) {
                            ignoreFileCustomObjects(metadataFromFileSystem[metadataTypeName], ignoredMetadata[metadataTypeName]);
                        }
                        break;
                    case MetadataTypes.CUSTOM_FIELD:
                    case MetadataTypes.INDEX:
                    case MetadataTypes.BUSINESS_PROCESS:
                    case MetadataTypes.COMPACT_LAYOUT:
                    case MetadataTypes.RECORD_TYPE:
                    case MetadataTypes.WEBLINK:
                    case MetadataTypes.VALIDATION_RULE:
                    case MetadataTypes.SHARING_REASON:
                    case MetadataTypes.LISTVIEW:
                    case MetadataTypes.FIELD_SET:
                        if (metadataFromFileSystem[metadataTypeName] && ignoredMetadata[metadataTypeName]) {
                            ignoreFileFromCustomObjects(metadataFromFileSystem[metadataTypeName], ignoredMetadata[metadataTypeName]);
                        }
                        break;
                    case MetadataTypes.EMAIL_TEMPLATE:
                    case MetadataTypes.REPORT:
                    case MetadataTypes.DASHBOARD:
                    case MetadataTypes.DOCUMENT:
                        if (metadataFromFileSystem[metadataTypeName] && ignoredMetadata[metadataTypeName]) {
                            ignoreFileMetadataFromFolders(metadataFromFileSystem[metadataTypeName], ignoredMetadata[metadataTypeName]);
                        }
                        break;
                    case MetadataTypes.PROFILE:
                    case MetadataTypes.PERMISSION_SET:
                        if (metadataFromFileSystem[metadataTypeName] && ignoredMetadata[metadataTypeName]) {
                            ignoreFromPermissionFiles(metadataFromFileSystem[metadataTypeName], ignoredMetadata[metadataTypeName], this.compress, this.sortOrder);
                        }
                        break;
                    default:
                        if (metadataFromFileSystem[metadataTypeName] && ignoredMetadata[metadataTypeName]) {
                            ignoreMetadataFiles(metadataFromFileSystem[metadataTypeName], ignoredMetadata[metadataTypeName]);
                        }
                        break;
                }
                this._event.emit(EVENTS.END_TYPE, metadataTypeName);
            }
        }
    }

}


function createIgnoreMetadataMap(ignoredMetadata: { [key: string]: string[] }): { [key: string]: any } {
    const ignoreMetadataMap: { [key: string]: any } = {};
    for (const metadataTypeName of Object.keys(ignoredMetadata)) {
        ignoreMetadataMap[metadataTypeName] = createIgnoreTypeMap(ignoredMetadata[metadataTypeName]);
    }
    return ignoreMetadataMap;
}

function createIgnoreTypeMap(objectsForIgnore: string[]): { [key: string]: any } {
    let objectToIgnoreMap: { [key: string]: any } = {};
    for (let objectToIgnore of objectsForIgnore) {
        if (objectToIgnore.indexOf(':') !== -1) {
            let splits = objectToIgnore.split(':');
            if (splits.length === 2) {
                if (!objectToIgnoreMap[splits[0]]) {
                    objectToIgnoreMap[splits[0]] = [];
                }
                objectToIgnoreMap[splits[0]].push(splits[1]);
            } else if (splits.length === 3 && splits[0].toLowerCase() === 'userpermission') {
                if (!objectToIgnoreMap['userpermission']) {
                    objectToIgnoreMap['userpermission'] = {};
                }
                if (!objectToIgnoreMap['userpermission'][splits[1]]) {
                    objectToIgnoreMap['userpermission'][splits[1]] = [];
                }
                objectToIgnoreMap['userpermission'][splits[1]].push(splits[2]);
            }
        } else {
            objectToIgnoreMap[objectToIgnore] = [objectToIgnore];
        }
    }
    return objectToIgnoreMap;
}

function ignoreMetadataCustomLabels(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }, singularType: MetadataType, remove: boolean): void {
    if (ignoredMetadata['*']) {
        if (metadataType) {
            Object.keys(metadataType.childs).forEach((objectKey) => {
                if (remove) {
                    delete metadataType.childs[objectKey];
                } else {
                    metadataType.childs[objectKey].checked = false;
                }
            });
        }
    }
    if (singularType) {
        let dataToRemove = [];
        let dataToKeep = [];
        Object.keys(singularType.childs).forEach((objectKey) => {
            if (ignoredMetadata['*'] || (ignoredMetadata[objectKey] && ignoredMetadata[objectKey].includes(objectKey))) {
                if (remove) {
                    delete singularType.childs[objectKey];
                } else {
                    singularType.childs[objectKey].checked = false;
                }
                dataToRemove.push(objectKey);
            } else {
                dataToKeep.push(objectKey);
            }
        });
        if (dataToRemove.length > 0) {
            if (metadataType) {
                Object.keys(metadataType.childs).forEach((objectKey) => {
                    if (remove) {
                        delete metadataType.childs[objectKey];
                    } else {
                        metadataType.childs[objectKey].checked = false;
                    }
                });
            }
        }
    }
}

function ignoreMetadataRules(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }, singularType: MetadataType, remove: boolean): void {
    if (ignoredMetadata['*']) {
        if (metadataType) {
            metadataType.checked = false;
            Object.keys(metadataType.childs).forEach((objectKey) => {
                if (remove) {
                    delete metadataType.childs[objectKey];
                } else {
                    metadataType.childs[objectKey].checked = false;
                }
            });
        }
    }
    if (singularType) {
        let dataToRemove = [];
        Object.keys(singularType.childs).forEach((objectKey) => {
            if (singularType.childs[objectKey].childs && Object.keys(singularType.childs[objectKey].childs).length > 0) {
                Object.keys(singularType.childs[objectKey].childs).forEach((itemKey) => {
                    if (ignoredMetadata['*'] || (ignoredMetadata[objectKey] && (ignoredMetadata[objectKey].includes(itemKey) || ignoredMetadata[objectKey].includes('*')))) {
                        if (remove) {
                            delete singularType.childs[objectKey].childs[itemKey];
                        }
                        else {
                            singularType.childs[objectKey].checked = false;
                            singularType.childs[objectKey].childs[itemKey].checked = false;
                        }
                        dataToRemove.push(objectKey + ':' + itemKey);
                    }
                });
                if (remove && singularType.childs[objectKey] && Object.keys(singularType.childs[objectKey].childs).length === 0) {
                    delete singularType.childs[objectKey];
                }
            } else if (ignoredMetadata['*'] || (ignoredMetadata[objectKey] && ignoredMetadata[objectKey].includes('*'))) {
                if (remove) {
                    delete singularType.childs[objectKey];
                } else {
                    singularType.childs[objectKey].checked = false;
                }
                dataToRemove.push(objectKey + ':*');
            }
        });
        if (dataToRemove.length > 0) {
            if (metadataType) {
                Object.keys(metadataType.childs).forEach((objectKey) => {
                    if (remove) {
                        delete metadataType.childs[objectKey];
                    } else {
                        metadataType.childs[objectKey].checked = false;
                    }
                });
            }
        }
    }
}

function ignoreMetadataWithChilds(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }, allTypes: { [key: string]: MetadataType }, remove: boolean): void {
    if (METADATA_WITH_CHILDS[metadataType.name]) {
        if (ignoredMetadata['*']) {
            Object.keys(metadataType.childs).forEach((objectKey) => {
                if (remove) {
                    delete metadataType.childs[objectKey];
                } else {
                    metadataType.childs[objectKey].checked = false;
                }
            });
            for (let childType of METADATA_WITH_CHILDS[metadataType.name]) {
                if (allTypes[childType]) {
                    Object.keys(allTypes[childType].childs).forEach((objectKey) => {
                        if (allTypes[childType] && allTypes[childType].childs[objectKey]) {
                            if (remove) {
                                delete allTypes[childType].childs[objectKey];
                            } else {
                                allTypes[childType].childs[objectKey].checked = false;
                                Object.keys(allTypes[childType].childs[objectKey].childs).forEach((itemKey) => {
                                    allTypes[childType].childs[objectKey].childs[itemKey].checked = false;
                                });
                            }
                        }
                    });
                }
            }
        } else {
            Object.keys(metadataType.childs).forEach((objectKey) => {
                if (ignoredMetadata[objectKey] && (ignoredMetadata[objectKey].includes(objectKey) || ignoredMetadata[objectKey].includes('*'))) {
                    if (remove) {
                        delete metadataType.childs[objectKey];
                    } else {
                        metadataType.childs[objectKey].checked = false;
                    }
                    for (let childType of METADATA_WITH_CHILDS[metadataType.name]) {
                        if (allTypes[childType] && allTypes[childType].childs[objectKey]) {
                            Object.keys(allTypes[childType].childs[objectKey].childs).forEach((itemKey) => {
                                if (remove) {
                                    delete allTypes[childType].childs[objectKey].childs[itemKey];
                                } else {
                                    allTypes[childType].childs[objectKey].childs[itemKey].checked = false;
                                }
                            });
                        }
                    }
                }
            });
        }
    } else {
        if (ignoredMetadata['*']) {
            Object.keys(metadataType.childs).forEach((objectKey) => {
                if (remove) {
                    delete metadataType.childs[objectKey];
                } else {
                    metadataType.childs[objectKey].checked = false;
                    Object.keys(metadataType.childs[objectKey].childs).forEach((itemKey) => {
                        metadataType.childs[objectKey].childs[itemKey].checked = false;
                    });
                }
            });
        } else {
            Object.keys(metadataType.childs).forEach((objectKey) => {
                let removeData = [];
                Object.keys(metadataType.childs[objectKey].childs).forEach((itemKey) => {
                    if (ignoredMetadata[objectKey] && (ignoredMetadata[objectKey].includes(itemKey) || ignoredMetadata[objectKey].includes('*'))) {
                        if (remove) {
                            delete metadataType.childs[objectKey].childs[itemKey];
                        } else {
                            metadataType.childs[objectKey].childs[itemKey].checked = false;
                        }
                        removeData.push(objectKey + ':' + itemKey);
                    }
                });
            });
        }

    }
}

function ignoreMetadataFromCustomObjects(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }, allTypes: { [key: string]: MetadataType }, remove: boolean): void {
    if (METADATA_WITH_CHILDS[metadataType.name]) {
        if (ignoredMetadata['*'] && ignoredMetadata['*'].includes('*')) {
            Object.keys(metadataType.childs).forEach((objectKey) => {
                if (remove) {
                    delete metadataType.childs[objectKey];
                } else {
                    metadataType.childs[objectKey].checked = false;
                }
            });
            for (let childType of METADATA_WITH_CHILDS[metadataType.name]) {
                if (allTypes[childType]) {
                    Object.keys(allTypes[childType].childs).forEach((objectKey) => {
                        if (remove) {
                            delete allTypes[childType].childs[objectKey];
                        } else {
                            allTypes[childType].childs[objectKey].checked = false;
                            Object.keys(allTypes[childType].childs[objectKey].childs).forEach((itemKey) => {
                                allTypes[childType].childs[objectKey].childs[itemKey].checked = false;
                            });
                        }
                    });
                }
            }
        } else if (ignoredMetadata['*']) {
            Object.keys(metadataType.childs).forEach((objectKey) => {
                if (remove) {
                    delete metadataType.childs[objectKey];
                } else {
                    metadataType.childs[objectKey].checked = false;
                }
            });
        } else {
            Object.keys(metadataType.childs).forEach((objectKey) => {
                if (ignoredMetadata[objectKey] && (ignoredMetadata[objectKey].includes(objectKey) || ignoredMetadata[objectKey].includes('*'))) {
                    if (remove) {
                        delete metadataType.childs[objectKey];
                    } else {
                        metadataType.childs[objectKey].checked = false;
                    }
                    if (ignoredMetadata[objectKey].includes('*')) {
                        for (let childType of METADATA_WITH_CHILDS[metadataType.name]) {
                            if (allTypes[childType] && allTypes[childType].childs[objectKey]) {
                                Object.keys(allTypes[childType].childs[objectKey].childs).forEach((itemKey) => {
                                    if (remove) {
                                        delete allTypes[childType].childs[objectKey].childs[itemKey];
                                    } else {
                                        allTypes[childType].childs[objectKey].childs[itemKey].checked = false;
                                    }
                                });
                            }
                        }
                    }
                }
            });
        }
    } else {
        if (ignoredMetadata['*']) {
            Object.keys(metadataType.childs).forEach((objectKey) => {
                if (remove) {
                    delete metadataType.childs[objectKey];
                } else {
                    metadataType.childs[objectKey].checked = false;
                    Object.keys(metadataType.childs[objectKey].childs).forEach((itemKey) => {
                        metadataType.childs[objectKey].childs[itemKey].checked = false;
                    });
                }
            });
        } else {
            Object.keys(metadataType.childs).forEach((objectKey) => {
                Object.keys(metadataType.childs[objectKey].childs).forEach((itemKey) => {
                    if (ignoredMetadata[objectKey] && (ignoredMetadata[objectKey].includes(itemKey) || ignoredMetadata[objectKey].includes('*'))) {
                        if (remove) {
                            delete metadataType.childs[objectKey].childs[itemKey];
                        } else {
                            metadataType.childs[objectKey].childs[itemKey].checked = false;
                        }
                    }
                });

            });
        }
    }
}

function ignoreOtherMetadataTypes(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }, remove: boolean): void {
    if (ignoredMetadata['*']) {
        Object.keys(metadataType.childs).forEach((objectKey) => {
            if (remove) {
                delete metadataType.childs[objectKey];
            } else {
                metadataType.childs[objectKey].checked = false;
                Object.keys(metadataType.childs[objectKey].childs).forEach((itemKey) => {
                    metadataType.childs[objectKey].childs[itemKey].checked = false;
                });
            }
        });
    } else {
        Object.keys(metadataType.childs).forEach((objectKey) => {
            if (ignoredMetadata[objectKey]) {
                if (ignoredMetadata[objectKey].includes('*') || ignoredMetadata[objectKey].includes(objectKey)) {
                    if (remove && (!metadataType.childs[objectKey].childs || Object.keys(metadataType.childs[objectKey].childs).length === 0)) {
                        delete metadataType.childs[objectKey];
                    } else {
                        if (!metadataType.childs[objectKey].childs || Object.keys(metadataType.childs[objectKey].childs).length === 0) {
                            metadataType.childs[objectKey].checked = false;
                        }
                        Object.keys(metadataType.childs[objectKey].childs).forEach((itemKey) => {
                            if (ignoredMetadata[objectKey] && (ignoredMetadata[objectKey].includes(itemKey) || ignoredMetadata[objectKey].includes('*'))) {
                                if (remove) {
                                    delete metadataType.childs[objectKey].childs[itemKey];
                                } else {
                                    metadataType.childs[objectKey].childs[itemKey].checked = false;
                                }
                            }
                        });
                    }
                } else {
                    Object.keys(metadataType.childs[objectKey].childs).forEach((itemKey) => {
                        if (ignoredMetadata[objectKey] && (ignoredMetadata[objectKey].includes(itemKey) || ignoredMetadata[objectKey].includes('*'))) {
                            if (remove) {
                                delete metadataType.childs[objectKey].childs[itemKey];
                            } else {
                                metadataType.childs[objectKey].childs[itemKey].checked = false;
                            }
                        }
                    });
                }
            }
        });
    }
}

function ignoreFromPermissionFiles(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }, compress: boolean, sortOrder: string): void {
    if (ignoredMetadata['*']) {
        if (metadataType.path && FileChecker.isExists(metadataType.path)) {
            FileWriter.delete(metadataType.path);
        }
    } else {
        Object.keys(metadataType.childs).forEach((objectKey) => {
            if (ignoredMetadata[objectKey]) {
                if (ignoredMetadata[objectKey].includes(objectKey)) {
                    const metadataObject = metadataType.getChild(objectKey);
                    if (metadataObject && metadataObject.path && FileChecker.isExists(metadataObject.path)) {
                        FileWriter.delete(metadataObject.path);
                    }
                }
            }
        });
        Object.keys(metadataType.childs).forEach((objectKey) => {
            const metadataObject = metadataType.getChild(objectKey);
            if (metadataObject && metadataObject.path && ignoredMetadata['userpermission'] && (ignoredMetadata['userpermission'][objectKey] || ignoredMetadata['userpermission']['*'])) {
                let xmlRoot = XMLParser.parseXML(FileReader.readFileSync(metadataObject.path), false);
                if (xmlRoot[metadataType.name] && xmlRoot[metadataType.name].userPermissions) {
                    xmlRoot[metadataType.name].userPermissions = Utils.forceArray(xmlRoot[metadataType.name].userPermissions);
                    let dataToRemove = [];
                    let dataToKeep = [];
                    for (let permission of xmlRoot[metadataType.name].userPermissions) {
                        if ((ignoredMetadata['userpermission']['*'] && ignoredMetadata['userpermission']['*'].includes(permission.name)) || (ignoredMetadata['userpermission'][objectKey] && ignoredMetadata['userpermission'][objectKey].includes(permission.name))) {
                            dataToRemove.push(permission);
                        } else {
                            dataToKeep.push(permission);
                        }
                    }
                    xmlRoot[metadataType.name].userPermissions = dataToKeep;
                    if (dataToRemove.length > 0) {
                        let content;
                        if (compress) {
                            content = new XMLCompressor().setXMLRoot(xmlRoot).setSortOrder(sortOrder).getCompressedContentSync();
                        } else {
                            content = XMLParser.toXML(xmlRoot);
                        }
                        FileWriter.createFileSync(metadataObject.path, content);
                    }
                }
            }
        });
    }
}

function ignoreFileCustomObjects(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }): void {
    if (ignoredMetadata['*'] && ignoredMetadata['*'].includes('*')) {
        if (metadataType.path && FileChecker.isExists(metadataType.path)) {
            FileWriter.delete(metadataType.path);
        }
    } else {
        Object.keys(metadataType.childs).forEach((objectKey) => {
            const metadataObject = metadataType.getChild(objectKey);
            if (ignoredMetadata[objectKey] && metadataObject && metadataObject.path) {
                if (ignoredMetadata[objectKey].includes(objectKey) || ignoredMetadata['*']) {
                    if (FileChecker.isExists(metadataObject.path)) {
                        FileWriter.delete(metadataObject.path);
                    }
                    let metaFile = metadataObject.path + '-meta.xml';
                    if (FileChecker.isExists(metaFile)) {
                        FileWriter.delete(metaFile);
                    }
                } else if (ignoredMetadata[objectKey].includes('*')) {
                    let folder = PathUtils.getDirname(metadataObject.path);
                    if (FileChecker.isExists(folder)) {
                        FileWriter.delete(folder);
                    }

                }
            }
        });
    }
}

function ignoreFileFromCustomObjects(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }): void {
    Object.keys(metadataType.childs).forEach((objectKey) => {
        const metadataObject = metadataType.getChild(objectKey);
        if (metadataObject) {
            if (ignoredMetadata['*'] || (ignoredMetadata[objectKey] && ignoredMetadata[objectKey].includes('*'))) {
                if (metadataObject.path && FileChecker.isExists(metadataObject.path)) {
                    FileWriter.delete(metadataObject.path);
                }
            } else if (ignoredMetadata[objectKey]) {
                Object.keys(metadataObject.getChilds()).forEach((itemKey) => {
                    const metadataItem = metadataObject.getChild(itemKey);
                    if (ignoredMetadata[objectKey].includes(itemKey) && metadataItem && metadataItem.path) {
                        if (FileChecker.isExists(metadataItem.path)) {
                            FileWriter.delete(metadataItem.path);
                        }
                    }
                });
            }
        }
    });
}

function ignoreMetadataFiles(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }): void {
    if (ignoredMetadata['*']) {
        if (metadataType.path && FileChecker.isExists(metadataType.path)) {
            FileWriter.delete(metadataType.path);
        }
    } else {
        Object.keys(metadataType.childs).forEach((objectKey) => {
            if (ignoredMetadata[objectKey]) {
                const metadataObject = metadataType.getChild(objectKey);
                if (metadataObject) {
                    if (metadataObject.hasChilds()) {
                        Object.keys(metadataObject.getChilds()).forEach((itemKey) => {
                            const metadataItem = metadataObject.getChild(itemKey);
                            if (metadataItem && metadataItem.path && (ignoredMetadata[objectKey].includes(itemKey) || ignoredMetadata[objectKey].includes('*'))) {
                                if (FileChecker.isExists(metadataItem.path)) {
                                    FileWriter.delete(metadataItem.path);
                                }
                                let metaFile = metadataItem.path + '-meta.xml';
                                if (FileChecker.isExists(metaFile)) {
                                    FileWriter.delete(metaFile);
                                }
                            }
                        });
                    } else {
                        if (metadataObject.path && (ignoredMetadata[objectKey].includes(objectKey) || ignoredMetadata[objectKey].includes('*'))) {
                            if (FileChecker.isExists(metadataObject.path)) {
                                FileWriter.delete(metadataObject.path);
                            }
                            let metaFile = metadataObject.path + '-meta.xml';
                            if (FileChecker.isExists(metaFile)) {
                                FileWriter.delete(metaFile);
                            }
                        }
                    }
                }
            }
        });
    }
}

function ignoreFileMetadataFromFolders(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }): void {
    if (ignoredMetadata['*']) {
        if (metadataType.path && FileChecker.isExists(metadataType.path)) {
            FileWriter.delete(metadataType.path);
        }
    } else {
        Object.keys(metadataType.childs).forEach((objectKey) => {
            const metadataObject = metadataType.getChild(objectKey);
            if (metadataObject && ignoredMetadata[objectKey]) {
                if (metadataObject.path && ignoredMetadata[objectKey].includes('*')) {
                    if (FileChecker.isExists(metadataObject.path)) {
                        FileWriter.delete(metadataObject.path);
                    }
                    let metaFile = metadataObject.path + '.' + metadataType.suffix + 'Folder-meta.xml';
                    if (FileChecker.isExists(metaFile)) {
                        FileWriter.delete(metaFile);
                    }
                } else {
                    Object.keys(metadataObject.getChilds()).forEach((itemKey) => {
                        const metadataItem = metadataObject.getChild(itemKey);
                        if (metadataItem && metadataItem.path && ignoredMetadata[objectKey].includes(itemKey)) {
                            if (FileChecker.isExists(metadataItem.path)) {
                                FileWriter.delete(metadataItem.path);
                            }
                            let metaFile = metadataItem.path + '-meta.xml';
                            if (FileChecker.isExists(metaFile)) {
                                FileWriter.delete(metaFile);
                            }
                        }
                    });
                }
            }
        });
    }
}

function ignoreFileMetadataFromFiles(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }, compress: boolean, sortOrder: string): void {
    let typeData = TYPES_XML_RELATION[metadataType.name];
    Object.keys(metadataType.childs).forEach((objectKey) => {
        if (ignoredMetadata[objectKey] || ignoredMetadata['*']) {
            let path = metadataType.path + '/' + objectKey + '.' + metadataType.suffix + '-meta.xml';
            if (FileChecker.isExists(path)) {
                let xmlRoot = XMLParser.parseXML(FileReader.readFileSync(path), false);
                if (xmlRoot[typeData.parentName] && xmlRoot[typeData.parentName][typeData.collection]) {
                    if ((ignoredMetadata[objectKey] && ignoredMetadata[objectKey].includes('*')) || ignoredMetadata['*']) {
                        xmlRoot[typeData.parentName][typeData.collection] = [];
                    } else if (ignoredMetadata[objectKey]) {
                        xmlRoot[typeData.parentName][typeData.collection] = Utils.forceArray(xmlRoot[typeData.parentName][typeData.collection]);
                        let dataToRemove = [];
                        let dataToKeep = [];
                        for (let xmlElement of xmlRoot[typeData.parentName][typeData.collection]) {
                            let elementKey = xmlElement[typeData.fieldKey];
                            if (ignoredMetadata[objectKey].includes(elementKey)) {
                                dataToRemove.push(xmlElement);
                            } else {
                                dataToKeep.push(xmlElement);
                            }
                        }
                        xmlRoot[typeData.parentName][typeData.collection] = dataToKeep;
                    }
                    let content;
                    if (compress) {
                        content = new XMLCompressor().setXMLRoot(xmlRoot).setSortOrder(sortOrder).getCompressedContentSync();
                    } else {
                        content = XMLParser.toXML(xmlRoot);
                    }
                    FileWriter.createFileSync(path, content);
                }
            }
        }
    });
}

function ignoreFileRules(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }, singularType: MetadataType, compress: boolean, sortOrder: string): void {
    let typeData = TYPES_XML_RELATION[metadataType.name];
    if (ignoredMetadata['*']) {
        if (metadataType.path && FileChecker.isExists(metadataType.path)) {
            FileWriter.delete(metadataType.path);
        }
    } else {
        if (singularType) {
            Object.keys(singularType.childs).forEach((objectKey) => {
                const metadataObject = singularType.getChild(objectKey);
                if (metadataObject && ignoredMetadata[objectKey]) {
                    if (metadataObject.path && ignoredMetadata[objectKey].includes('*')) {
                        if (FileChecker.isExists(metadataObject.path)) {
                            FileWriter.delete(metadataObject.path);
                        }
                    } else {
                        let path = metadataType.path + '/' + objectKey + '.' + metadataType.suffix + '-meta.xml';
                        if (FileChecker.isExists(path)) {
                            let xmlRoot = XMLParser.parseXML(FileReader.readFileSync(path), false);
                            let dataToKeep: any[] = [];
                            let dataToRemove: any[] = [];
                            Object.keys(singularType.childs[objectKey].childs).forEach((_itemKey) => {
                                if (xmlRoot[metadataType.name] && xmlRoot[metadataType.name][typeData.collection]) {
                                    xmlRoot[metadataType.name][typeData.collection] = Utils.forceArray(xmlRoot[metadataType.name][typeData.collection]);
                                    for (let xmlElement of xmlRoot[metadataType.name][typeData.collection]) {
                                        let elementKey = xmlElement[typeData.fieldKey];
                                        if (ignoredMetadata[objectKey] && ignoredMetadata[objectKey].includes(elementKey)) {
                                            dataToRemove.push(xmlElement);
                                        } else {
                                            dataToKeep.push(xmlElement);
                                        }
                                    }
                                    xmlRoot[metadataType.name][typeData.collection] = dataToKeep;
                                }
                            });
                            if (dataToRemove.length > 0) {
                                let content;
                                if (compress) {
                                    content = new XMLCompressor().setXMLRoot(xmlRoot).setSortOrder(sortOrder).getCompressedContentSync();
                                } else {
                                    content = XMLParser.toXML(xmlRoot);
                                }
                                FileWriter.createFileSync(path, content);
                            }
                        }
                    }
                }
            });
        }
    }
}

function ignoreFileCustomLabels(metadataType: MetadataType, ignoredMetadata: { [key: string]: any }, compress: boolean, sortOrder: string): void {
    let typeData = TYPES_XML_RELATION[metadataType.name];
    if (ignoredMetadata['*']) {
        if (metadataType.path && FileChecker.isExists(metadataType.path)) {
            FileWriter.delete(metadataType.path);
        }
    } else {
        let path = metadataType.childs[metadataType.name].path;
        if (path && FileChecker.isExists(path)) {
            let xmlRoot = XMLParser.parseXML(FileReader.readFileSync(path), false);
            if (xmlRoot[metadataType.name] && xmlRoot[metadataType.name][typeData.collection]) {
                let dataToKeep = [];
                let dataToRemove = [];
                xmlRoot[metadataType.name][typeData.collection] = Utils.forceArray(xmlRoot[metadataType.name][typeData.collection]);
                for (let xmlElement of xmlRoot[metadataType.name][typeData.collection]) {
                    let elementKey = xmlElement[typeData.fieldKey];
                    if (ignoredMetadata[elementKey] && ignoredMetadata[elementKey].includes(elementKey)) {
                        dataToRemove.push(xmlElement);
                    } else {
                        dataToKeep.push(xmlElement);
                    }
                }
                xmlRoot[metadataType.name][typeData.collection] = dataToKeep;
                if (dataToRemove.length > 0) {
                    let content;
                    if (compress) {
                        content = new XMLCompressor().setXMLRoot(xmlRoot).setSortOrder(sortOrder).getCompressedContentSync();
                    } else {
                        content = XMLParser.toXML(xmlRoot);
                    }
                    FileWriter.createFileSync(path, content);
                }
            }
        }
    }
}